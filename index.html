<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GeoTiff sample</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      width: 100%;
    }

    #images {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
    }
  </style>
</head>

<body>
  <div id="images"></div>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.13.0/css/ol.css" type="text/css">
  <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.13.0/build/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
  <style media="screen">
    .map {
      position: absolute;
      top: 5px;
      bottom: 5px;
      left: 5px;
      right: 5px;
    }
  </style>
  <div id="map" class="map"></div>
  <script>
    var bingRoad = new ol.layer.Tile({
      visible: true,
      preload: Infinity,
      name: 'Bing Road',
      source: new ol.source.BingMaps({
        key: 'OR4jawvlzJkSpZV1JKxh~B_CAibllXzRX1f69gB-vsQ~AmzjZ1xIDQF-XPoVbJfgITtHRNUuZP0wZc3aX9tbMC6UWpM3VgxCcOg0IBbKz_X-',
        imagerySet: 'AerialWithLabelsOnDemand',
        crossOrigin: 'Anonymous'
      }),
    });
    var dragAndDropInteraction = new ol.interaction.DragAndDrop({
      formatConstructors: [ol.format.GPX, ol.format.GeoJSON, ol.format.IGC, ol.format.TopoJSON],
    });
    var raster = null;
    var map = new ol.Map({
      interactions: ol.interaction.defaults().extend([dragAndDropInteraction]),
      // controls: ol.control.defaults().extend([scaleControl(), new ol.control.FullScreen()]),
      layers: [
        bingRoad
      ],
      target: 'map',
      view: new ol.View({
        center: [0, 0],
        zoom: 2
      }),
    });

    async function displayImage(data) {
      const tiff = await GeoTIFF.fromArrayBuffer(data);
      const img = await tiff.getImage();
      const width = img.getWidth();
      const height = img.getHeight();
      const subfileNumber = await tiff.getImageCount();

      const readImageData = async (image, options = {}) => {
        const rasters = await image.readRasters(options);
        const {
          width,
          height
        } = rasters;
        const band = image.getSamplesPerPixel();
        const arr = []; //custom array for canvas
        for (let i = 0; i < rasters[0].length; i++) { //loop through first band
          if (band > 1) { // for multiple bands
            if (rasters[0][i] == 0 && rasters[1][i] == 0 && rasters[2][i] == 0) {
              // hide pixels having value 0 for all 3 bands i-e: black pixels
              arr[i * 4] = rasters[0][i]; //r
              arr[i * 4 + 1] = rasters[1][i]; //g
              arr[i * 4 + 2] = rasters[2][i]; //b
              arr[i * 4 + 3] = 0; //a
            } else {
              arr[i * 4] = rasters[0][i];
              arr[i * 4 + 1] = rasters[1][i];
              arr[i * 4 + 2] = rasters[2][i];
              arr[i * 4 + 3] = 255;
            }
          } else {
            arr[i * 4] = rasters[0][i];
            arr[i * 4 + 1] = rasters[0][i];
            arr[i * 4 + 2] = rasters[0][i];
            arr[i * 4 + 3] = 255;
          }
        }
        const data = new Uint8ClampedArray(arr);
        return new ImageData(data, width, height);
      }

      const showImage = async (subfileIndex) => {
        const image = await tiff.getImage(subfileIndex);
        const maxSize = 1024;
        let startX = parseInt((image.getWidth() - width) / 2);
        if (startX < 0) startX = 0;
        let endX = parseInt((image.getWidth() + width) / 2);
        if (endX > image.getWidth())
          endX = image.getWidth();

        let startY = parseInt((image.getHeight() - height) / 2);
        if (startY < 0) startY = 0;
        let endY = parseInt((image.getHeight() + height) / 2);
        if (endY > image.getHeight()) {
          endY = image.getHeight();
        }
        const data = await readImageData(image, {
          window: [startX, startY, endX, endY]
        });

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const extent = image.getBoundingBox();
        canvas.width = width;
        canvas.height = height;
        ctx.putImageData(data, 0, 0);
        raster = new ol.layer.Image({
          source: new ol.source.ImageStatic({
            url: canvas.toDataURL(),
            projection: 'EPSG:4326',
            imageExtent: extent
          }),
          title: "GeoTIFF",
          visible: true
        });
        map.addLayer(raster);
        zoomToExtent(ol.proj.transformExtent(extent, 'EPSG:4326', 'EPSG:3857'));
      }
      for (let i = 0; i < subfileNumber; i++) {
        await showImage(i)
      }
    }

    map.getViewport().addEventListener('drop', function(event) {
      var name = event.dataTransfer.files[0].name;
      if (name.indexOf("tif") !== -1) {
        event.preventDefault();
        const files = event.dataTransfer.files;
        files[0].arrayBuffer().then(displayImage);

      }
    });

    function zoomToExtent(extent) {
      map.getView().fit(extent, {
        duration: 1000,
        padding: [50, 50, 50, 50]
      });
    }
  </script>
</body>

</html>
